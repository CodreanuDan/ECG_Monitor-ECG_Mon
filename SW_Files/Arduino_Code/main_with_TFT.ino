/* Main.ino file generated by New Project wizard
 *
 * Created:   Tue Dec 30 2025
 * Processor: Arduino Uno
 * Compiler:  Arduino AVR (Proteus)
 */

/* ===== Those objects are declared here due to Proteus strange AVR complier ===== */

/* ========== Data structures ========== */
#define BUFFER_SIZE 250 // Each ECG signal is made from 250 samples
typedef struct
{
	int data[BUFFER_SIZE];
	uint8_t head;
	uint8_t tail;
	uint8_t count;
} CircularBuffer;

CircularBuffer ecg_buffer;

#define HIST_SIZE 10  // Keep the last 10 RR interval values 
typedef struct
{
	long data[HIST_SIZE];
	uint8_t index;
	uint8_t count;
} HistBuffer;

HistBuffer rr_buffer;

/* ========== Peripheral Configuration Code (do not edit) ========== */

//---CONFIG_BEGIN---
#pragma GCC push_options
#pragma GCC optimize ("Os")

#include <core.h> // Required by cpu
#include <cpu.h>
#include <spi.h> // Required by spi
#include <spiport.h>
#include <wire.h> // Required by i2c
#include <i2cport.h>

#pragma GCC pop_options

// Peripheral Constructors
CPU &cpu = Cpu;
SpiPort &spi = Spi;
I2CPort &i2c = I2C;

void peripheral_setup () {
 spi.begin ();
 i2c.begin ();
}

void peripheral_loop() {
}
//---CONFIG_END---
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <Adafruit_SPIDevice.h>  

/* ========== ECG Mon Data ========== */

/* Debug config */
#define ECG_DGB_EN 1
#define TFT_EN 0

/* TFT Config */
#define TFT_DC 9
#define TFT_CS 10
#define TFT_RST 8

Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);

/* Pin definitions */
#define SIGNAL_PIN A0

/* ADC constants */
#define ADC_VREF 1.1f
#define ADC_MAX_VAL 1024u
#define ADC_RES 10u

/* Bias configuration - signal centered on Vref/2 */
#define ADC_BIAS_VOLTAGE (ADC_VREF / 2.0f)  // 0.55V
#define ADC_BIAS_VALUE (ADC_MAX_VAL / 2)    // 512 (ADC value at bias)

/* ADC variables for High Pass filter (removes baseline wander)*/
volatile float baseline = 512.0f;  //  (512 = 0.55V)
volatile float filtered_value = 0.0f;

/* Sampling constants */
#define ECG_SAMPLE_PERIOD_MS 1u //  1 kHz sample rate

/* BPM variables */
#define BPM_ALPHA 0.15f

volatile int r_val = 0;
volatile int r_max_val = 85;
const int min_inter_beat_interval = 300; // 200bpm

volatile float rr_interval_current = 0.0f;
volatile float rr_interval_avg = 0.0f;
volatile float rr_interval_ema = 0.0f;

volatile float bpm_ema = 0.0f;
volatile float bpm_avg = 0.0f;
volatile float bpm_current = 0.0f;

/* QRS complex variables */
#define WINDOW_SIZE 20u
float qrs_avg_buffer[WINDOW_SIZE];
volatile uint8_t qrs_avg_index = 0;
volatile uint8_t qrs_avg_count = 0;
#define QRS_THRESHOLD 0.05f
volatile float qrs_duration_ms = 0.0f;

/* TFT coord */
int x_pos = 0;
int last_y = 120;

/* ========== Function prototypes ========== */

/* Circular buffer functions (FIFO) */
void buffer_init(CircularBuffer* buff);
bool buffer_write(CircularBuffer* buff, int value);
int buffer_read(CircularBuffer* buff);
bool buffer_is_empty(CircularBuffer* buff);
bool buffer_is_full(CircularBuffer* buff);

/* History buffer functions */
void hist_buffer_init(HistBuffer* buff);
bool hist_buffer_write(HistBuffer* buff, int value);
long hist_buffer_get_avg(HistBuffer* buff);
bool hist_buffer_is_empty(CircularBuffer* buff);
bool hist_buffer_is_full(CircularBuffer* buff);

/* History buffer diagnostic functions for heart rate variation (HRV) */
float hrv_sdnn(HistBuffer* buff); // SDNN - Standard Deviation of NN intervals (normal-to-normal RR)
float hrv_rmssd(HistBuffer* buff); // RMSSD - Root Mean Square of Successive Differences
uint8_t hrv_nn50(HistBuffer* buff); // NN50 - Number of consec interv. that differ in 50ms in len 
float hrv_pnn50(HistBuffer* buff); // pNN50 - % of number of consec interv. that differ > 50ms in len

/* Helpers */
float convert_raw_to_voltage(int value);
float moving_avg_filter(float value, float* buffer, volatile uint8_t* idx, volatile uint8_t* cnt);
float ema_filter(float value, volatile float* ema_val, float alpha); // Estimated Moving Avergae Filter (EMA)
float convert_raw_to_mv_centered(int value);
void PrintData();

/* ECG functions */
void ECG_Proc_MainFunction();
void ECG_Proc_GetRawSample();
void ECG_Proc_GetMaxPeak(int raw_val);
void ECG_Proc_GetInstRpeak(int raw_val);
void ECG_Proc_GetBPM(int raw_val);
void ECG_Proc_GetQRSWidth(int raw_val);

/* TFT functions */
void TFT_UpdateDashboard();
void TFT_DrawECGTrace(int val);

/* Timer1 ISR Prototype */
ISR(TIMER1_COMPA_vect);

/* Core functions */
void setup();
void loop();

/* ========== ARDUINO CORE FUNCTIONS ========== */

void setup() 
{
	peripheral_setup();
	// TODO: put your setup code here, to run once:

	analogReference(INTERNAL);
	
	/* Configure Timer1 for 1000 Hz */
    cli();                           // stop cycles
    TCCR1A = 0;
    TCCR1B = 0;
    TCNT1 = 0;
    OCR1A = 1999;                    // 16MHz / 8 / 1000Hz - 1 = 1999
    TCCR1B |= (1 << WGM12);          // CTC mode
    TCCR1B |= (1 << CS11);           // prescaler 8
    TIMSK1 |= (1 << OCIE1A);         // activate interrupt at compare match
    sei();                           // activate interrupts

	buffer_init(&ecg_buffer);
	hist_buffer_init(&rr_buffer);

	tft.begin();
    tft.setRotation(1);
    tft.fillScreen(ILI9341_BLACK);
	tft.drawFastVLine(210, 0, 240, ILI9341_WHITE);

	Serial.begin(9600);

	tft.setCursor(215, 5);
    tft.setTextColor(ILI9341_WHITE);
    tft.setTextSize(1);
    tft.print(" DATA PANEL");
}

void loop() 
{
	peripheral_loop();
	// TODO: put your main code here, to run repeatedly:
	ECG_Proc_MainFunction();
}

/* ===== Function definitions ===== */

/* ~~~ Timer1 ISR ~~~*/
ISR(TIMER1_COMPA_vect)
{
    int raw_val = analogRead(SIGNAL_PIN);      
    buffer_write(&ecg_buffer, raw_val);        
}

/* ~~~ Circular buffer functions (LIFO) ~~~*/

/*
 * Func. name: buffer_init
 * @param: CircularBuffer* buff
 * @brief: Init an empty circular buffer
 */
void buffer_init(CircularBuffer* buff)
{
	buff->head = 0;
	buff->tail = 0;
	buff->count = 0;
}

/*
 * Func. name: buffer_write
 * @param: CircularBuffer* buff, int value
 * @brief: Write a value at the head of the buffer (FIFO)
 */
bool buffer_write(CircularBuffer* buff, int value)
{
	if (buffer_is_full(buff)) return false;
	buff->data[buff->head] = value;
	buff->head = (buff->head + 1) % BUFFER_SIZE;
	buff->count++;
	return true;
}

/*
 * Func. name: buffer_read
 * @param: CircularBuffer* buff
 * @brief: Read the value from the tail of the buffer (FIFO), then remove it
 */
int buffer_read(CircularBuffer* buff)
{
	if (buffer_is_empty(buff)) return -1;
	int value = buff->data[buff->tail];
	buff->tail = (buff->tail + 1) % BUFFER_SIZE;
	buff->count--;
	return value;
}

bool buffer_is_empty(CircularBuffer* buff)
{
	return buff->count == 0;
}

bool buffer_is_full(CircularBuffer* buff)
{
	return buff->count == BUFFER_SIZE;
}

/* ~~~ History buffer functions ~~~*/

/*
 * Func. name: hist_buffer_init
 * @param: HistBuffer* buff
 * @brief: Init an empty circular buffer
 */
void hist_buffer_init(HistBuffer* buff)
{
	buff->index = 0;
	buff->count = 0;
}

/*
 * Func. name: hist_buffer_write
 * @param: HistBuffer* buff, int value
 * @brief: Write a value at the head of the buffer (FIFO)
 */
bool hist_buffer_write(HistBuffer* buff, int value)
{
	buff->data[buff->index] = value;
	buff->index = (buff->index + 1) % HIST_SIZE;
	if (buff->count < HIST_SIZE) 
	{
		buff->count++;
	}

	return true;
}

/*
 * Func. name: hist_buffer_get_avg
 * @param: HistBuffer* buff
 * @brief: Get the average value of buffer data (moving average filter kind of)
 */
long hist_buffer_get_avg(HistBuffer* buff)
{
	if (hist_buffer_is_empty(buff)) return 0;

	long sum = 0;
	for (uint8_t i = 0; i < buff->count; i++)
	{
		sum += buff->data[i];
	}

	return sum / buff->count;
}

bool hist_buffer_is_empty(HistBuffer* buff)
{
	return buff->count == 0;
}

bool hist_buffer_is_full(HistBuffer* buff)
{
	return buff->count == HIST_SIZE;
}


/* History buffer diagnostic functions for heart rate variation (HRV) */

/*
 * Func. name: hrv_sdnn
 * @param: HistBuffer* buff
 * @brief: SDNN - Standard Deviation of NN intervals (normal-to-normal RR)
 *         - Interpretation of the value:
 *           a. Bigger SDNN: normal variablity / healthy
 *           b. Smaller SDNN: rigid rithm / stress 
 */
float hrv_sdnn(HistBuffer* buff)
{
    if (buff->count < 2) return 0.0f;

    float avg = hist_buffer_get_avg(buff);
    float sum_sq = 0.0f;
    for (uint8_t i = 0; i < buff->count; i++)
    {
        float diff = buff->data[i] - avg;
        sum_sq += diff * diff;
    }
    return sqrt(sum_sq / (buff->count - 1));
}

/*
 * Func. name: hrv_rmssd
 * @param: HistBuffer* buff
 * @brief: RMSSD - Root Mean Square of Successive Differences
 *         - Interpretation of the value:
 *           a. Bigger RMSSD: ok for parasimpatic / relaxed
 *           b. Smaller RMSSD: sympathetic activity / stress 
 */
float hrv_rmssd(HistBuffer* buff)
{
    if (buff->count < 2) return 0.0f;

    float sum_sq_diff = 0.0f;
    for (uint8_t i = 1; i < buff->count; i++)
    {
        float diff = buff->data[i] - buff->data[i-1];
        sum_sq_diff += diff * diff;
    }
    return sqrt(sum_sq_diff / (buff->count - 1));
}

/*
 * Func. name: hrv_nn50
 * @param: HistBuffer* buff
 * @brief: NN50 - Number of consec interv. that differ but over 50ms in len 
 */
uint8_t hrv_nn50(HistBuffer* buff)
{
    if (buff->count < 2) return 0;

    uint8_t count = 0;
    for (uint8_t i = 1; i < buff->count; i++)
    {
        if (abs((int)buff->data[i] - (int)buff->data[i-1]) > 50)
            count++;
    }
    return count;
}


/*
 * Func. name: hrv_pnn50
 * @param: HistBuffer* buff
 * @brief: % of number of consec interv. that differ but over 50ms in len 
 *         - Interpretation of the value:
 *           % consecutive intervals >50ms ?  classic indicator for parasimpatic HRV
 */
float hrv_pnn50(HistBuffer* buff)
{
    if (buff->count < 2) return 0;
    return 100.0f * hrv_nn50(buff) / (buff->count - 1);
}



/* Helpers */

/*
 * Func. name: convert_raw_to_voltage
 * @param: int value
 * @brief: Gonvert ADC data to volatge
 */
float convert_raw_to_voltage_centered(int value)
{
    float voltage_absolute = (value * ADC_VREF) / ADC_MAX_VAL;
    
    float voltage_centered = voltage_absolute - ADC_BIAS_VOLTAGE;
    
    return voltage_centered;
}

/*
 * Func. name: convert_raw_to_mv_centered
 * @param: int value
 * @brief: Converte?te ADC direct în mV centrat (mai practic pentru afi?are)
 * @return: Tensiune în mV relativa la bias
 */
float convert_raw_to_mv_centered(int value)
{
    return convert_raw_to_voltage_centered(value) * 1000.0f;
}

/*
 * Func. name: moving_avg_filter
 * @param: float value, float* buffer, volatile uint8_t* idx, volatile uint8_t* cnt, uint8_t win_size
 * @brief: Apply Moving Average Filter for specific values contained in a buffer 
 */
float moving_avg_filter(float value, float* buffer, volatile uint8_t* idx, volatile uint8_t* cnt, uint8_t win_size)
{
	buffer[*idx] = value;
	*idx = (*idx + 1) %  win_size;

	if (*cnt < win_size)
	{
		(*cnt)++;
	}

	float sum = 0.0f;
	for (uint8_t i = 0; i < *cnt; i++)
	{
		sum += buffer[i];
	}

	if (*cnt == 0) return value;

	return sum / (float)(*cnt);
}

/*
 * Func. name: ema_filter
 * @param: float value, volatile float* ema_val, float alpha
 * @brief: Apply Estimated Moving Average Filter (EMA) for specific values
 */
float ema_filter(float value, volatile float* ema_val, float alpha)
{
	static bool ema_init = false;

	if (!ema_init)
	{
		*ema_val = value;
		ema_init = true;
	}
	else
	{
		*ema_val = alpha * value + (1.0f - alpha) * (*ema_val);
	}
	
	return *ema_val;
}

/*
 * Func. name: PrintData
 * @param: None
 * @brief: Print data to Serial Monitor or send it the HMI
 */
void PrintData()
{
	static unsigned long last_print_time  = 0;

	unsigned long now = millis();

	if (now - last_print_time > 1000)
	{
		Serial.print("|inst.BPM:");Serial.print(bpm_current, 1);
		Serial.print("|avg.BPM:");Serial.print(bpm_avg, 1);

		Serial.print("|inst.R:");Serial.print(r_val);Serial.print("mV");
		Serial.print("|max.R:");Serial.print(r_max_val);Serial.print("mV");

		Serial.print("|per.QRS:");Serial.print(qrs_duration_ms);;Serial.print("ms");

		Serial.print("|inst.RR:");Serial.print(rr_interval_current);;Serial.print("ms");
		Serial.print("|avg.RR:");Serial.print(rr_interval_avg);;Serial.print("ms");

		Serial.print("|HRV_SDNN:"); Serial.print(hrv_sdnn(&rr_buffer), 1);
		Serial.print("|HRV_RMSSD:"); Serial.print(hrv_rmssd(&rr_buffer), 1);
		Serial.print("|HRV_pNN50:"); Serial.print(hrv_pnn50(&rr_buffer), 1);

		Serial.println();

		last_print_time = now;
	}
}

/* ~~~ ECG functions ~~~*/

/*
 * Func. name: ECG_Proc_MainFunction
 * @param: None
 * @brief: Main function for processing the ECG signal 
 */
void ECG_Proc_MainFunction()
{
    if (buffer_is_empty(&ecg_buffer)) return;

	int raw_val = buffer_read(&ecg_buffer);
    
	/* RII High-pass filter: FIXED - init baseline to first raw value */
    static bool first_sample = true;
    if (first_sample) 
	{
        baseline = raw_val;
        first_sample = false;
    }
	
	baseline = 0.995f * baseline + 0.005f * raw_val;
    filtered_value = raw_val - baseline;

	/* Display: re-center around 512 */
    int val_for_display = (int)(filtered_value + 512);

#if TFT_EN
    TFT_DrawECGTrace(val_for_display);
#endif
	
	/* Processing: use filtered centered value */
    int val_filtered = (int)filtered_value;
	
	ECG_Proc_GetMaxPeak(val_filtered);
    ECG_Proc_GetInstRpeak(val_filtered);
    ECG_Proc_GetBPM(val_filtered);
    ECG_Proc_GetQRSWidth(val_filtered);

#if TFT_EN
    TFT_UpdateDashboard();
#endif

    #if ECG_DGB_EN
        PrintData();
    #endif
}

/*
 * Func. name: ECG_Proc_GetRawSample
 * @param: None
 * @brief: Read ADC raw data at a specified sample rate and write data in the ecg circular buffer
 */
void ECG_Proc_GetRawSample()
{
	static unsigned long last_sample_time = 0;

	unsigned long current_time = millis();
	
	if (current_time - last_sample_time >= ECG_SAMPLE_PERIOD_MS)
	{
		int adc_raw_val = analogRead(SIGNAL_PIN);
		buffer_write(&ecg_buffer, adc_raw_val);

		last_sample_time = current_time;
	}
}

/*
 * Func. name: ECG_Proc_GetMaxPeak
 * @param: int raw_val
 * @brief: Update R component max peak value and detect inst peak value
 */
void ECG_Proc_GetMaxPeak(int filtered_val)
{
    /* Track max R peak with slow decay */
    if (filtered_val >= r_max_val) 
	{
        r_max_val = filtered_val;
    } 
	else 
	{
        r_max_val = (int)(r_max_val * 0.9998f);
        if (r_max_val < 30) r_max_val = 30;
    }
}

/*
 * Func. name: ECG_Proc_GetInstRpeak
 * @param: int raw_val
 * @brief: Detect instant R peak value
 */
void ECG_Proc_GetInstRpeak(int filtered_val)
{
    int peak_threshold = 0.95 * r_max_val;
    static int prev_filtered = 0;
    static int prev_d = 0;

    int d = filtered_val - prev_filtered;
    
    if (filtered_val > peak_threshold) 
	{
        if (prev_d > 0 && d <= 0) 
		{
            r_val = filtered_val;
        }
    }

    prev_filtered = filtered_val;
    prev_d = d;
}

/*
 * Func. name: ECG_Proc_GetBPM
 * @param: int raw_val
 * @brief: Measure time between thersholds around R compoenet peak and calculate BPM (60000 / rr_interval;)
 */
void ECG_Proc_GetBPM(int filtered_val )
{
    static unsigned long last_beat_time = 0;

    int peak_threshold = 0.8 * r_max_val;

    if (filtered_val  > peak_threshold)
    {
        unsigned long current_time = millis();

        if (current_time - last_beat_time > min_inter_beat_interval)
        {
            /* Get RR interval */
            unsigned long rr_interval_raw = current_time - last_beat_time;

            hist_buffer_write(&rr_buffer, rr_interval_raw);
            rr_interval_avg = hist_buffer_get_avg(&rr_buffer);
            rr_interval_current = rr_interval_raw;

            /* Calculate BPM */
            float bpm_raw = 60000.0f / rr_interval_raw;
            bpm_current = bpm_raw;
            bpm_avg = ema_filter(bpm_raw, &bpm_ema, BPM_ALPHA);
            
            last_beat_time = current_time;
        }
    }
}

/*
 * Func. name: ECG_Proc_GetQRSWidth
 * @param: int raw_val
 * @brief: Measure counts between thersholds around R compoenet and detrmine QRS full width (Q left shoulder ~ S right shoulder)
 */
void ECG_Proc_GetQRSWidth(int filtered_val)
{
    static int qrs_counter = 0;
    static bool in_qrs = false;
    
    /* Lower threshold to catch QRS complex */
    int base_threshold = (int)(QRS_THRESHOLD * r_max_val);

    if (!in_qrs && filtered_val > base_threshold)
    {
        in_qrs = true;
        qrs_counter = 0;
    }
    else if (in_qrs && filtered_val < base_threshold)
    {
        /* Filter noise: Valid QRS: 60-120ms typical */
        if (qrs_counter >= 60 && qrs_counter <= 150)
        {
            qrs_duration_ms = qrs_counter * ECG_SAMPLE_PERIOD_MS;
        }
        in_qrs = false;
    }
    else if (in_qrs)
    {
        qrs_counter++;
    }
}

/* ~~~ TFT functions ~~~*/

/*
 * Func. name: TFT_UpdateDashboard
 * @param: None
 * @brief: 
 */
void TFT_UpdateDashboard() 
{
    static unsigned long last_print_time = 0;
    unsigned long now = millis();

    if (now - last_print_time > 1000) {
        tft.fillRect(221, 20, 99, 220, ILI9341_BLACK);
        tft.setTextSize(1);
        
        tft.setTextColor(ILI9341_RED);
        tft.setCursor(225, 25); tft.print("BPM Avg:"); tft.print((int)bpm_avg);
        tft.setCursor(225, 35); tft.print("BPM Inst:"); tft.print((int)bpm_current);
        
        tft.setTextColor(ILI9341_YELLOW);
        tft.setCursor(225, 55); tft.print("R Peak:"); tft.print(r_val);tft.print("mV");

        tft.setTextColor(ILI9341_GREEN);
        tft.setCursor(225, 85); tft.print("QRS:"); tft.print((int)qrs_duration_ms); tft.print("ms");

        tft.setTextColor(ILI9341_MAGENTA);
        tft.setCursor(225, 105); tft.print("RR Avg:"); tft.print((int)rr_interval_avg);tft.print("mV");
        tft.setCursor(225, 115); tft.print("RR Ins:"); tft.print((int)rr_interval_current);tft.print("mV");

        tft.drawFastHLine(221, 135, 99, ILI9341_WHITE);
        tft.setTextColor(ILI9341_CYAN);
        tft.setCursor(225, 145); tft.print("SDNN:"); tft.print(hrv_sdnn(&rr_buffer), 1);
        tft.setCursor(225, 155); tft.print("RMSSD:"); tft.print(hrv_rmssd(&rr_buffer), 1);

        last_print_time = now;
    }
}

/*
 * Func. name: TFT_DrawECGTrace
 * @param: int val
 * @brief: 
 */
void TFT_DrawECGTrace(int val)
{
    static unsigned long last_print_time = 0;
    unsigned long now = millis();

    if (now - last_print_time > 10)
    {
        /* ADC: 0-1024 -> TFT: 230-10 (up-down) */

		//int y_now = map(val, 0, 1024, 230, 10);
		int y_now = map(val, 362, 662, 230, 10);
        
        /* Radar sweep */
        tft.drawFastVLine(x_pos + 2, 0, 240, ILI9341_BLACK);
        
        if (x_pos >= 218) 
        {
            tft.drawFastVLine(0, 0, 240, ILI9341_BLACK);
        }
        
        tft.drawFastHLine(0, 120, 210, ILI9341_DARKGREY);
        
        tft.drawLine(x_pos, last_y, x_pos + 1, y_now, ILI9341_GREEN);
        
        last_y = y_now;
        x_pos++;
        if (x_pos >= 219) x_pos = 0;

        last_print_time = now;
    }
}

/* */

